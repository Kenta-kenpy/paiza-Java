// P共通テスト過去問題1　★
D// お釣り
import java.util.Scanner;

public class Main {  // クラス名を Main に変更
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        int S = scanner.nextInt(); // 商品の合計金額
        int M = scanner.nextInt(); // 支払われた金額
        scanner.close();
        
        if (M >= S) {
            System.out.println(M - S);
        } else {
            System.out.println("Tarimasen!");
        }
    }
}
/*もし支払金額が十分であれば、返金額を表示し、足りなければ「Tarimasen!」というエラーメッセージを出力します。
具体的には、Scanner クラスを使って商品金額 S と支払金額 M を受け取り、条件分岐を使って支払いが適切かを判断します。
支払いが足りていれば、M - S を計算して返金額を表示し、足りなければ「Tarimasen!」を表示します。*/

C// rot-x
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // 入力を受け取る
        int n = sc.nextInt();   // 文字列の長さ
        String s = sc.next();    // 平文 s
        String t = sc.next();    // 暗号文 t
        
        // 文字のシフト量を格納するためのマップ
        Map<Integer, Integer> rot = new HashMap<>();
        
        // 各文字のシフト量を計算し、マップに格納
        for (int i = 0; i < n; i++) {
            int shift = (t.charAt(i) - s.charAt(i) + 26) % 26;  // シフト量を計算
            rot.put(shift, rot.getOrDefault(shift, 0) + 1);  // シフト量の出現回数をカウント
        }
        
        // シフト量の種類が1つの場合、正しい暗号文と判断
        if (rot.size() == 1) {
            // シフト量が1種類だけの場合
            System.out.println("correct rot-" + rot.keySet().iterator().next());
        }
        // シフト量の種類が2つの場合
        else if (rot.size() == 2) {
            // マップのエントリをリスト化して、頻度を比較
            List<Map.Entry<Integer, Integer>> entries = new ArrayList<>(rot.entrySet());
            entries.sort((a, b) -> Integer.compare(a.getValue(), b.getValue()));
            
            // 出現頻度が少ない方のシフト量が1回なら修正が可能
            if (entries.get(0).getValue() == 1) {
                // 1回だけ間違っているので修正する
                StringBuilder fixedT = new StringBuilder(t);
                int wrongShift = entries.get(0).getKey();
                int correctShift = entries.get(1).getKey();
                
                for (int i = 0; i < n; i++) {
                    if ((t.charAt(i) - s.charAt(i) + 26) % 26 == wrongShift) {
                        // 間違っている文字を修正
                        fixedT.setCharAt(i, (char) ('a' + (s.charAt(i) - 'a' + correctShift) % 26));
                    }
                }
                // 修正した暗号文を出力
                System.out.println("fixed " + fixedT.toString());
            } else {
                // 出現頻度が1回でない場合は修正不可
                System.out.println("incorrect");
            }
        }
        // シフト量の種類が3種類以上の場合、修正は不可能
        else {
            System.out.println("incorrect");
        }
        
        // Scannerを閉じる
        sc.close();
    }
}
/*与えられた平文 s と暗号文 t に対して、どのようなシフト量（右シフト）が適用されたかを計算し、その結果に基づいて暗号文が正しいか、1文字のみ間違っているか、または2文字以上間違っているかを判断します。
入力の読み取り
最初に、Scanner を使って入力を読み取ります。
1行目で、文字列 s と t の長さ n を読み取ります。
2行目で平文 s を、3行目で暗号文 t を読み取ります。

シフト量の計算
各文字について、平文 s の文字と暗号文 t の文字のシフト量を計算します。シフト量は、文字 s[i] から文字 t[i] へのシフト量を求めます。
シフト量の計算方法は、(t[i] - s[i] + 26) % 26 です。これは、文字が負のシフト量になるのを防ぎ、常に正のシフト量を計算するためです。

シフト量のカウント
計算したシフト量を Map<Integer, Integer> に格納し、各シフト量が何回現れたかをカウントします。シフト量はキーとして、出現回数は値として保存されます。
例えば、もしシフト量 2 が3回現れ、シフト量 3 が2回現れる場合、rot は {2: 3, 3: 2} となります。

シフト量の判定
次に、シフト量が1種類だけの場合、2種類の場合、またはそれ以上の種類の場合に分けて処理を行います。
(1) シフト量が1種類の場合
もし rot.size() が1ならば、すべての文字が同じシフト量で変換されているため、暗号文は正しい暗号文であり、correct rot-x を出力します。ここで x はそのシフト量です。
(2) シフト量が2種類の場合
rot.size() が2の場合、シフト量が2種類存在していることを意味します。この場合、2つのシフト量がどのように出現しているかに基づいて次の処理を行います：
まず、rot マップのエントリをリストに変換し、出現頻度が少ないシフト量を1回だけ間違っていると仮定します。
出現頻度が1回のシフト量が1つだけ存在する場合、その1文字を修正する処理を行います。具体的には、その文字を正しいシフト量で修正して fixed t' を出力します。
出現頻度が1回でない場合は修正ができないため、incorrect を出力します。
(3) シフト量がそれ以上の場合
rot.size() が3以上の場合、シフト量が3種類以上存在しているため、暗号文が間違っていると判断し、incorrect を出力します。

シフト量が2種類の場合で、1回だけ間違っている文字を修正する場合、修正は次のように行われます：
t[i] の文字が間違っているシフト量に該当する場合、その文字を平文 s[i] から正しいシフト量を適用して修正します。
例えば、間違ってシフト量 2 が適用された文字を、正しいシフト量 3 に基づいて修正します。

最後に、条件に応じて適切な結果を出力します：
シフト量が1種類ならば correct rot-x を出力。
シフト量が2種類で1回だけ間違っているならば fixed t' を出力。
シフト量が3種類以上または修正できない場合は incorrect を出力。

文字列 s, t の各文字について、それぞれ何文字右シフトされているかを求め、問題文の指示に従って答えを出力すればよいです。
全文字がそれぞれ何文字右シフトされているかを集計する際は、長さ 26 の整数型配列や連想配列などを用いるとよいです。*/

B// リング型のトークンパッシング
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // 端末の数 N とトークンの要求回数 K を入力
        int N = sc.nextInt();
        int K = sc.nextInt();
        
        // 累積和を計算する配列
        int[] tSum = new int[N + 1];
        tSum[0] = 0;
        
        // 各端末間の通信時間を累積和として格納
        for (int i = 0; i < N; i++) {
            int t = sc.nextInt();
            tSum[i + 1] = tSum[i] + t;
        }
        
        long ans = 0;
        int last = 0; // 現在のトークン位置（インデックス）
        
        // 各トークン要求の端末番号を処理
        for (int i = 0; i < K; i++) {
            int d = sc.nextInt() - 1; // 0-based index に変換
            
            // 以前の位置より小さい場合は一周する必要がある
            if (d <= last) {
                ans += tSum[N] - tSum[last];
                ans += tSum[d];
            } else {
                ans += tSum[d] - tSum[last];
            }
            
            last = d;
        }
        
        // 最短の合計時間を出力
        System.out.println(ans);
    }
}
/*このコードは トークンパッシング方式 を用いたネットワーク通信のシミュレーションを行い、最短の合計時間を求めるものです。
具体的には、トークンが 時計回り に端末を巡回し、各端末がトークンを要求するたびに、トークンの移動時間 を計算して合計していきます。
入力の読み込み
端末の数 N と トークン要求回数 K を取得。
各端末間の通信時間 T を取得し、累積和（トークンが端末1から各端末まで移動するのにかかる時間）を計算。

累積和の作成
tSum[i] を作成し、端末 1 から i までの移動時間 を格納。
tSum[i] = tSum[i-1] + T[i-1] の形で累積していく。

トークン移動のシミュレーション
トークンの初期位置を 端末 1 に設定（last = 0）。
各要求端末 D[i] を処理。
D[i] が現在の位置 last よりも後（大きい）なら、tSum[D[i]] - tSum[last] で移動時間を加算。
D[i] が現在の位置よりも前（小さい）なら、一周する必要があるため、
tSum[N] - tSum[last] + tSum[D[i]] を計算して加算。
last を D[i] に更新し、次の要求に備える。

結果の出力
計算したトークン移動の合計時間 ans を出力。

ポイント
累積和の利用
任意の2端末間の移動時間を O(1) で求める ために累積和 tSum を使用。
tSum[j] - tSum[i] で、端末 i から j までの移動時間が即座に計算できる。

リング構造の考慮
D[i] が last より小さい場合は、一周分の移動時間 tSum[N] を加算して考慮。

計算量の最適化
各トークン要求を O(1) で処理できるため、全体の計算量は O(N + K) となり、大規模な入力でも高速に処理可能。*/

A// データの分類
import java.util.*;

class Point {
    int x, y, c;
    
    // コンストラクタ: 座標 (x, y) とクラス c を初期化
    public Point(int x, int y, int c) {
        this.x = x;
        this.y = y;
        this.c = c;
    }
}

public class KNNClassifier {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // データの個数
        List<Point> points = new ArrayList<>();
        
        // n 個のデータを読み込み、リストに格納
        for (int i = 0; i < n; i++) {
            int x = sc.nextInt();
            int y = sc.nextInt();
            int c = sc.nextInt();
            points.add(new Point(x, y, c));
        }
        
        // クラス不明のデータの座標を取得
        int x0 = sc.nextInt();
        int y0 = sc.nextInt();
        int q = sc.nextInt(); // クエリの個数
        int[] kValues = new int[q];
        
        // k の値を読み込む
        for (int i = 0; i < q; i++) {
            kValues[i] = sc.nextInt();
        }
        
        // 距離の計算とソート
        points.sort((p1, p2) -> {
            int d1 = (p1.x - x0) * (p1.x - x0) + (p1.y - y0) * (p1.y - y0); // p1 との距離の2乗
            int d2 = (p2.x - x0) * (p2.x - x0) + (p2.y - y0) * (p2.y - y0); // p2 との距離の2乗
            
            // 距離が同じ場合は、クラスの値が小さい方を優先
            if (d1 == d2) return Integer.compare(p1.c, p2.c);
            return Integer.compare(d1, d2);
        });
        
        // クラスのカウントと解の計算
        TreeMap<Integer, Integer> classCount = new TreeMap<>(); // クラスごとの出現回数を管理
        int[] results = new int[n];
        int maxCount = 0; // 最も多く出現するクラスの出現回数
        int bestClass = Integer.MAX_VALUE; // 現在の最良クラス
        
        // 先頭から k 近傍を構築しつつ、最頻クラスを記録
        for (int i = 0; i < n; i++) {
            int cls = points.get(i).c;
            classCount.put(cls, classCount.getOrDefault(cls, 0) + 1);
            int count = classCount.get(cls);
            
            // 多数決で最も多く出現するクラスを更新
            if (count > maxCount || (count == maxCount && cls < bestClass)) {
                maxCount = count;
                bestClass = cls;
            }
            results[i] = bestClass;
        }
        
        // クエリの処理
        StringBuilder sb = new StringBuilder();
        for (int k : kValues) {
            sb.append(results[k - 1]).append("\n"); // k-1 番目の結果を出力
        }
        System.out.print(sb);
    }
}
/*距離の計算、ソート、k近傍の処理を効率的に行うため、PriorityQueueとTreeMapを使用しています。
データの読み込み
n 個の (x, y, c) の座標情報をリスト points に格納。
クラス不明のデータ (x0, y0) を取得。
クエリ数 q と各 k を取得。

距離の計算とソート
(x - x0)² + (y - y0)² を距離の基準とし、昇順にソート。
同じ距離の場合、クラスの値が小さい方を優先。

k 近傍の管理と最頻クラスの決定
TreeMap<Integer, Integer> でクラスの出現回数を管理。
出現回数が最も多いクラスを追跡し results[i] に格納。

クエリ処理
事前計算済みの results を利用して O(1) でクエリに回答。
この方法により、大規模なデータに対しても高速に分類可能です。*/

S// ペイントソフト
import java.util.*;

public class Main {
    // 4方向移動 (上下左右) を示す配列
    static int[] dx = {0, 0, 1, -1}; 
    static int[] dy = {1, -1, 0, 0};

    // 長方形内に座標が含まれるか判定する関数
    public static boolean isPointSquareIn(int num, int[] p, int x, int y) {
        if (num == 0) {
            // 赤色長方形 (0,0) -> (x1, y1) の範囲内
            return x < p[0] && y < p[1];
        } else if (num == 1) {
            // 青色長方形 (0, H) -> (x2, y2) の範囲内
            return x < p[0] && y > p[1];
        } else if (num == 2) {
            // 緑色長方形 (W, H) -> (x3, y3) の範囲内
            return x > p[0] && y > p[1];
        } else {
            // 黄色長方形 (W, 0) -> (x4, y4) の範囲内
            return x > p[0] && y < p[1];
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 塗りつぶし回数
        int q = sc.nextInt(); // クエリ回数
        int h = sc.nextInt(); // キャンバスの高さ
        int w = sc.nextInt(); // キャンバスの幅

        // 長方形の4つの座標を格納
        int[][] point = new int[4][2];
        for (int i = 0; i < 4; i++) {
            point[i][0] = sc.nextInt(); // x座標
            point[i][1] = sc.nextInt(); // y座標
        }

        // 交差条件のフラグ
        boolean llUrCrossing = false;
        boolean ulLrCrossing = false;

        // 長方形の交差状態を計算
        int size = 0;
        if (point[0][0] >= point[2][0] && point[0][1] >= point[2][1]) {
            // 長方形が交差している場合
            size++;
            llUrCrossing = true; // 左下右上交差
        }
        if (point[1][0] >= point[3][0] && point[1][1] <= point[3][1]) {
            // 長方形が交差している場合
            size++;
            ulLrCrossing = true; // 左上右下交差
        }

        // 色の状態を格納する配列（長方形の組み合わせに対応）
        int[] colorOfArea = new int[1 << (4 + size)];
        Arrays.fill(colorOfArea, 1); // 初期状態はすべて白色 (1)

        // 塗りつぶし処理
        for (int i = 0; i < n; i++) {
            int c = sc.nextInt(); // 塗りつぶす色
            int x = sc.nextInt(); // 塗りつぶす座標x
            int y = sc.nextInt(); // 塗りつぶす座標y

            // 塗りつぶすエリアを識別するためのIDを計算
            int id = 0;
            int add = 0;

            // クリックした座標が各長方形内かを判定
            for (int j = 0; j < 4; j++) {
                if (isPointSquareIn(j, point[j], x, y)) {
                    id += 1 << j; // 各長方形の番号に対応したビットをセット
                }
            }

            // 交差状態に基づいてIDをさらに更新
            if (llUrCrossing) {
                if (x > point[0][0] && y < point[2][1]) {
                    id += 1 << (4 + add); // 左下右上交差の条件に一致
                }
                add++;
            }

            if (ulLrCrossing) {
                if (x < point[3][0] && y < point[1][1]) {
                    id += 1 << (4 + add); // 左上右下交差の条件に一致
                }
            }

            // 塗りつぶし
            colorOfArea[id] = c; // 対応するIDのエリアを指定した色に塗りつぶし
        }

        // クエリ処理
        for (int i = 0; i < q; i++) {
            int x = sc.nextInt(); // クエリの座標x
            int y = sc.nextInt(); // クエリの座標y

            // 座標に対応するエリアIDを計算
            int id = 0;
            int add = 0;

            // クリックした座標が各長方形内かを判定
            for (int j = 0; j < 4; j++) {
                if (isPointSquareIn(j, point[j], x, y)) {
                    id += 1 << j; // 各長方形の番号に対応したビットをセット
                }
            }

            // 交差状態に基づいてIDをさらに更新
            if (llUrCrossing) {
                if (x > point[0][0] && y < point[2][1]) {
                    id += 1 << (4 + add); // 左下右上交差の条件に一致
                }
                add++;
            }

            if (ulLrCrossing) {
                if (x < point[3][0] && y < point[1][1]) {
                    id += 1 << (4 + add); // 左上右下交差の条件に一致
                }
            }

            // 結果を出力 (その位置の色を出力)
            System.out.println(colorOfArea[id]);
        }

        sc.close();
    }
}
/*座標判定関数 (isPointSquareIn):

この関数は与えられた座標 (x, y) が、指定された長方形内に含まれるかどうかを判定します。
num 引数は、どの長方形に関する判定をするかを指定するために使います。長方形の位置に応じて x と y がその長方形内に収まるかを確認します。
長方形の交差判定 (llUrCrossing と ulLrCrossing):

長方形が交差している場合、キャンバス上に複雑な塗りつぶしの区画ができるため、その状態を判定します。
交差条件が満たされると、それに対応するフラグ (llUrCrossing や ulLrCrossing) が true になります。
色の状態管理:

colorOfArea 配列に、各エリアの色を格納します。エリアを特定するために、ビットフラグを使って長方形の組み合わせを管理します。エリアごとに色を設定し、塗りつぶし操作が行われると、そのエリアの色が更新されます。
塗りつぶし処理:

塗りつぶし操作が行われると、指定された座標 (px, py) がどのエリアに該当するかを判定し、対応するエリアの色を更新します。
塗りつぶしの際、交差条件に応じてエリアIDを調整することがあります。
クエリ処理:

各クエリに対して、指定された座標 (qx, qy) がどのエリアに該当するかを判定し、そのエリアの色を出力します。塗りつぶされていないエリアは白色 (1) で表示されます。
注意点
長方形の交差状態や、複雑な領域分けを考慮した処理が必要であり、ビットフラグを使ってエリアを管理しています。
長方形が交差している場合の処理の際に、llUrCrossing や ulLrCrossing フラグを用いて、エリアIDを細かく調整しています。*/

S// 画像の切り抜き
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 入力: 画像の縦 H, 横 W, 切り抜く長方形の最小縦 N, 最小横 M
        int H = sc.nextInt();
        int W = sc.nextInt();
        int N = sc.nextInt();
        int M = sc.nextInt();
        sc.nextLine(); // 整数入力後の改行を消費

        // 画像の各行を格納
        String[] a = new String[H];
        for (int i = 0; i < H; i++) {
            a[i] = sc.nextLine(); // 各行を文字列として読み込む
        }

        // 二分探索の精度設定
        int prec = 40;
        double valid = 0.0, sup = 2.0;

        // 二分探索を使って最大の黒さを探す
        for (int t = 0; t < prec; t++) {
            // 黒さの中間値を計算
            double mid = (valid + sup) / 2.0;

            // 累積和を格納する2次元配列を初期化
            double[][] sum = new double[H + 1][W + 1];

            // 画像を累積和で処理する
            for (int i = 1; i <= H; i++) {
                for (int j = 1; j <= W; j++) {
                    sum[i][j] = 0.0;
                    // 白（'0'）と黒（'1'）に対して異なる値を設定
                    if (a[i - 1].charAt(j - 1) == '1') {
                        sum[i][j] += (1.0 - mid); // 黒マスの累積和
                    } else {
                        sum[i][j] -= mid; // 白マスの累積和
                    }
                    // 累積和の公式
                    sum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
                }
            }

            // 各列の累積和を保持する配列
            double[] work = new double[W + 1];
            double[] mx = new double[W + 1];
            boolean flag = false; // 長方形が見つかったかどうかを判定するフラグ

            // 各長方形の領域をチェック
            for (int i = 0; i <= H - N; i++) { // 上端を決める
                for (int j = i + N; j <= H; j++) { // 下端を決める
                    // i から j までの各列に対して差分を計算
                    for (int k = 0; k <= W; k++) {
                        work[k] = sum[j][k] - sum[i][k]; // 上端 i から下端 j までの黒さの差
                    }

                    // 最大値を右から累積
                    for (int k = W; k >= 0; k--) {
                        mx[k] = work[k];
                        if (k < W) {
                            mx[k] = Math.max(mx[k], mx[k + 1]); // 最大の黒さの差を維持
                        }
                    }

                    // M列以上の長方形が存在するかチェック
                    for (int k = M; k <= W; k++) {
                        if (-work[k - M] + mx[k] >= 0.0) { // 黒さの差が0以上ならばフラグを立てる
                            flag = true;
                        }
                    }
                }
            }

            // フラグが立ったら黒さがmid以上であることが確認できたため、validを更新
            if (flag) {
                valid = mid;
            } else {
                // そうでなければ、黒さの上限を更新
                sup = mid;
            }
        }

        // 最後に結果を10桁の精度で出力
        System.out.printf("%.10f\n", valid);
    }
}
/*ロジックの解説
入力処理:
H, W, N, Mはそれぞれ画像の縦横のサイズ、および最小の切り抜き長方形の縦横サイズです。
次に、各行の白黒画像を格納するために、aという配列に各行の文字列を格納します。画像は0（白）と1（黒）で構成されています。
二分探索の準備:
二分探索を使って、長方形の「黒さ」を最大化します。validとsupで現在探索している黒さの範囲を保持し、黒さの中間値midを計算します。
累積和の計算:
2次元累積和を用いて、任意の長方形領域に含まれる黒いマスの数を効率的に求められるようにします。sum[i][j]には、(0, 0)から(i-1, j-1)までの範囲における、黒マスの重み付き和を格納します。
もしその位置が黒マス（'1'）なら、黒さを(1.0 - mid)に、白マス（'0'）なら-midに設定します。
長方形領域の探索:
iを上端、jを下端とする長方形の範囲を探索します。
長方形内の黒さの合計を求めるために、sum[j][k] - sum[i][k]の差分を計算し、それを利用して各列の黒さを計算します。
右端における最大値の保持:
各列に対して右から累積して、最大値mx[k]を維持します。これにより、任意の長方形が黒さの条件を満たすかどうかを効率的に判定できます。
条件の判定:
-work[k - M] + mx[k] >= 0.0を使って、黒さがmid以上の長方形が存在するかをチェックします。もし存在すれば、flagをtrueに設定し、validを更新します。
二分探索の更新:
もしflagがtrueならば、その黒さmidは有効であるため、validを更新します。flagがfalseならば、黒さの上限supを更新して再探索します。
結果の出力:
最後に、探索で得られた最大の黒さvalidを10桁の精度で出力します。*/

// P共通テスト過去問題2　★
D// 拡散の脅威
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // 入力を取得
        int A = scanner.nextInt(); // タロー君の投稿のリツイート数
        int B = scanner.nextInt(); // リツイートした人達の平均フォロワー数
        int C = scanner.nextInt(); // タロー君のフォロワー数
        
        scanner.close();
        
        // 計算 (リツイートされた回数 × 平均フォロワー数) + タロー君のフォロワー数
        int result = A * B + C;
        
        // 結果を出力
        System.out.println(result);
    }
}
/*Scannerクラスの利用
Scanner クラスを使用して、標準入力から整数値を3つ取得します。
int A = scanner.nextInt(); → タロー君の投稿のリツイート数を取得
int B = scanner.nextInt(); → リツイートした人たちの平均フォロワー数を取得
int C = scanner.nextInt(); → タロー君のフォロワー数を取得
計算の実行
(A * B + C) という式を用いて、投稿が最大何人に見られたかを計算します。
A * B は、リツイートされた回数ごとに新しく見られる可能性のあるフォロワーの数
C は、タロー君のフォロワーが直接投稿を見られる人数
この2つを足すことで、最大視聴可能人数を求めます。
結果の出力
System.out.println(result); を使って計算結果を出力します。                    
リソースの解放
scanner.close(); で Scanner を閉じ、リソースの無駄遣いを防ぎます。*/

C// 正確なフィッティング （最小二乗法）
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // タロー君が求めた小数 a を入力
        double a = scanner.nextDouble();  
        // データの数 n を入力
        int n = scanner.nextInt();        
        
        long xySum = 0; // Σ x_i * y_i の合計を保持
        long xxSum = 0; // Σ x_i^2 の合計を保持
        
        // n 個のデータを読み込み、xySum と xxSum を計算
        for (int i = 0; i < n; i++) {
            int x = scanner.nextInt();
            int y = scanner.nextInt();
            xySum += (long) x * y;
            xxSum += (long) x * x;
        }
        
        scanner.close();
        
        // 最小二乗法による傾き α' を計算
        double accurateA = (double) xySum / xxSum;
        // 小数第5位を四捨五入
        accurateA = Math.round(accurateA * 10000.0) / 10000.0;
        
        // タロー君の求めた a と比較し、結果を出力
        if (a == accurateA) {
            System.out.println("Yes");
        } else {
            System.out.println("No");
        }
    }
}
/*このプログラムは、最小二乗法を用いてデータを直線 y=αx にフィッティングし、タロー君が求めた傾きが正しいかを判定するものです。
Scanner を使って標準入力を受け付けます。1行目の a はタロー君が求めた傾きの値（小数第4位までの数値）。2行目の n は与えられるデータの数（2 ≦ n ≦ 10,000）。
xySum には ∑𝑥𝑖𝑦𝑖（x座標とy座標の積の合計）を格納。xxSum には ∑𝑥𝑖2（x座標の2乗の合計）を格納。
n 回のループを回し、各データ点 (𝑥𝑖,𝑦𝑖)を入力。xySum と xxSum を計算して累積。Scanner を閉じ、リソースを解放。
最小二乗法による最適な傾き 𝛼′ を計算。小数第5位を四捨五入し、小数第4位までの精度に変換。
タロー君が求めた値 a と、計算された accurateA を比較。
一致すれば "Yes"、異なれば "No" を出力。*/

B// パリティチェック
A// PC重ね
S// JUMP!!!
S// 数論階層クラスタリング







