<【次元配列の入出力】i番目の出力 Boss>
step1　要素数の出力
public class Main {

    public static void main(String[] args) {
        int[] a = new int[] { 5, 1, 3, 4, 5, 12, 6, 8, 1, 3 };

        System.out.println(a.length);
    }
}
/*vector を与えられた数列で初期化します。
要素数を出力します。
Java では、配列定義時に格納する要素が決まっている場合は int[] a = new int[] {n_1, n_2, ..., n_N}; などのように記述します。
定義の際、new int[] は省略することが可能です。
配列の要素数は 配列.length で取得出来ます。*/

step2　全要素の出力
public class Main {

    public static void main(String[] args) {
        int[] a = new int[] { 5, 1, 3, 4, 5, 12, 6, 8, 1, 3 };

        for (int x : a) {
            System.out.println(x);
        }
    }
}
/*vector を与えられた数列で初期化します。全要素を改行区切りで出力します。
指示された数列を配列を用いて管理します。
出力の際、for 文を用いると簡潔に記述できます。
今回は拡張 for 文を使いました。
【 拡張 for 文について 】
拡張 for 文は配列やリストなどのオブジェクトの各要素を順に変数に代入して繰り返し処理ができる for 文のことです。
【 書き方 】
for(要素の型 変数名 : 配列など) {処理} のように書きます。
配列などのオブジェクトに格納されている値の型に応じた変数を用意する必要があります。
【 動作 】
配列などのオブジェクトの先頭の要素から順に変数に代入され、繰り返し処理が行われます。
たとえば、要素数 n の整数型配列 a に対して
for(int i : a) {System.out.println(i)}
と記述した for 文の実行結果は以下のようになります。
a_1 
a_2
a_3
...
a_n
*/
    
step3　i番目の出力
public class Main {

    public static void main(String[] args) {
        int[] a = new int[] { 5, 1, 3, 4, 5, 12, 6, 8, 1, 3 };

        System.out.println(a[3]);
    }
}
/*指定された数列を配列で管理します。
配列のインデックスは 0 から始まることに注意して下さい。
インデックス 0 が 1 番目の要素となるので、4 番目の要素のインデックスは 3 になります。*/

step4　配列の入力１
public class Main {

    public static void main(String[] args) {
        int[] a = new int[] { 8, 1, 3, 3, 8, 1, 1, 3, 8, 8 };

        for (int x : a) {
            System.out.println(x);
        }
    }
}
/*指定された数列を配列を用いて管理します。
出力の際、拡張 for 文を使いました。*/

step5　配列の入力２
import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int[] a = new int[10];
        for (int i = 0; i < 10; i++) {
            a[i] = sc.nextInt();
        }

        for (int x : a) {
            System.out.println(x);
        }

        sc.close();
    }
}
/*vector を与えられた数列で初期化します。
全要素を改行区切りで出力します。入力される 10 個の整数を管理するために、整数型で長さ 10 の配列を用意します。
整数型で長さ 10 の配列を用意するには int[] a = new int[10]; のように記述します。
入力は Scanner クラスの nextInt メソッドで受け取っています。
nextInt メソッドは入力値を整数型で受け取るために用意されているメソッドです。
出力は拡張 for 文を利用すると、簡潔に書けます。*/

step6　配列の入力３
import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();

        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }

        for (int x : a) {
            System.out.println(x);
        }

        sc.close();
    }
}
/*整数 N を受け取ります。
長さ N の vector を宣言します。
ループを用いて N 個の整数を受け取ります。
全要素を改行区切りで出力します。まず、「何個の整数 a_i が入力されるか」を表す整数 n が入力されるので、整数型で長さ n の配列を用意します。
入力は Scanner クラスの nextInt メソッドで受け取りながら、配列に代入していきます。
出力は拡張 for 文を利用すると簡潔に書けます。*/

step7  i番目の出力１
import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int k = sc.nextInt();
        int[] a = new int[] { 1, 3, 5, 4, 6, 2, 1, 7, 1, 5 };

        System.out.println(a[k - 1]);

        sc.close();
    }
}
/*整数 K を受け取ります。
vector を与えられた数列で初期化します。
K 番目の要素を出力します。
配列のインデックスは 0 から始まるので、k 番目の要素のインデックスは k-1 であることに注意して下さい。*/

step8　i番目の出力２
import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int k = sc.nextInt();

        int[] a = new int[10];
        for (int i = 0; i < 10; i++) {
            a[i] = sc.nextInt();
        }

        System.out.println(a[k - 1]);

        sc.close();
    }
}
/*整数 K を受け取ります。
ループを用いて 10 個の整数を受け取ります。
K 番目の要素を出力します。入力される 10 個の整数を配列を用いて受け取ります。
配列のインデックスは 0 から始まるので、k 番目の要素のインデックスは k-1 であることに注意して下さい。*/

final  i番目の出力Boss
import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int k = sc.nextInt();

        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }

        System.out.println(a[k - 1]);

        sc.close();
    }
}
/*整数 N と K を受け取ります。
ループを用いて N 個の整数を受け取ります。
K 番目の要素を出力します。n 個の整数を保持するために、整数型で長さ n の配列を用意して入力値を受け取ります。
配列のインデックスは 0 から始まるので、k 番目の要素のインデックスは k-1 となることに注意して下さい。*/

<【二次元配列の入出力】i番目の出力 Boss>
step1　要素数の出力
public class Main {

    public static void main(String[] args) {
        int[][] a = new int[][] { { 1, 2, 3, 4, 5, 6 }, { 8, 1, 3, 3, 1, 8 } };

        int row = a.length;
        int column = a[0].length;
        System.out.println(row * column);
    }
}
/*予め要素が決まっている 2 次元配列は上記のコードのように定義します。
この 2 次元配列が持っている要素の総数は 行数 * 列数 で出すことができるので、a.length * a[0].length で求めることができます。
なぜ上記の式になるのか、について以下で説明します。
【 要素の総数が a.length * a[0].length で求まる理由 】
a.length について
これは 2 次元配列 a が持っている要素の数を取得するコードです。
a に含まれる要素の数は 12 なので a.length の値も 12 ではないか、と思われるかもしれませんが、実はこの値は 2 となります。
これは、2 次元配列 a が持っている要素が
1 次元配列 {1, 2, 3, 4, 5, 6}
1 次元配列 {8, 1, 3, 3, 1, 8}
の 2 つだからです。
以上のことから a.length は 2 次元配列 a の行の数を表しています。
a[0].length について
これは 2 次元配列 a のインデックス 0 に格納されている配列の要素数を取得するコードです。
a に格納されている 2 つの配列の要素数はどちらも変わらないので、a[1].length でも同じ結果が得られます。
以上のことから a[0].length は 2 次元配列 a の列の数を表しています。*/

step2　全要素の出力
public class Main {

    public static void main(String[] args) {
        int[][] a = new int[][] { { 6, 5, 4, 3, 2, 1 }, { 3, 1, 8, 8, 1, 3 } };

        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[i].length; j++) {
                System.out.print(a[i][j]);
                if (j < a[i].length - 1) {
                    System.out.print(" ");
                } else {
                    System.out.println();
                }
            }
        }
    }
}
/*出力の箇所は 2 重ループで書きます。
外側のループは 2 次元配列の「行」についての処理をします。
内側のループは 2 次元配列の「列」についての処理をします。
j の値に注目して a[i][j] の次に出力する文字が「改行」か「半角スペース」かを判定します。
j が i 行目の最後の要素のインデックスを示すとき、つまり、j=a[i].length-1 のときは「改行」を、それ以外のときは「半角スペース」を、出力するように書くと上手くいきます。*/

step3　行数の出力
public class Main {

    public static void main(String[] args) {
        int[][] a = new int[][] { { 1, 2, 3 }, { 4, 5, 6 }, { 8, 1, 3 } };

        System.out.println(a.length);
    }
}
/*行の数は a.length で取得することができます。
なぜかというと、 a が持っている要素の数がそのまま行の数に一致するからです。
少し詳しく説明します。
a が持っている要素は
配列 {1, 2, 3}
配列 {4, 5, 6}
配列 {8, 1, 3}
の 3 つの配列です。
つまり、2 次元配列 a が持っている要素としてカウントされるのは上に挙げた 3 つの 1 次元配列です。
従って、a.length は 2 次元配列 a の行数を示します。*/

step4　列数の出力
public class Main {

    public static void main(String[] args) {
        int[][] a = new int[][] {
            { 1, 2, 3, 4 },
            { 6, 5, 4, 3 },
            { 3, 1, 8, 1 },
        };

        System.out.println(a[0].length);
    }
}
/*vector を与えられた数列で初期化します。二次元配列の列数を出力します。
列の数は a[0].length で取得することができます。
なぜかというと、 a[0] が持つ要素の数が列の数に一致するからです。
少し詳しく説明します。
a[0] が持っている要素は
整数 1
整数 2
整数 3
整数 4
の 4 つの整数です。
つまり、1 次元配列 a が持っている要素としてカウントされるのは、上に挙げた 4 つの整数です。
これは、 2 次元配列 a の列の数に一致します。*/

step5　各行の要素数の出力
public class Main {

    public static void main(String[] args) {
        int[][] a = new int[][] { { 1 }, { 2, 3 }, { 4, 5, 6 } };

        for (int[] x : a) {
            System.out.println(x.length);
        }
    }
}
/*vector を与えられた数列で初期化します。
各行の要素数を出力します。
i 行目の列の数が a[i].length で表されることは、前問で確認しました。
今回は、全ての行に関して列の数を出力することが求められています。
for 文を使うことでこの問題は簡潔に解けます。
解答コードでは拡張 for 文を使って記述しています。
2 次元配列 a の要素である 1 次元配列が順に変数 x に代入されるので、System.out.println(x.length); として x の要素数を出力します。
2 次元配列 a の各要素は 1 次元配列なので x の型を int[] とすることに注意して下さい。*/

step6　i行目j列目の出力
public class Main {

    public static void main(String[] args) {
        int[][] a = new int[][] { { 1, 2, 3 }, { 8, 1, 3 }, { 10, 100, 1 } };

        System.out.println(a[1][2]);
    }
}
/*vector を与えられた数列で初期化します。
2 行目 3 列目の要素を出力します。
配列のインデックスは 0 から始まっているので 2 次元配列の x 行 y 列目の要素は a[x-1][y-1] に格納されています。
よって、2 行 3 列目の要素は a[2-1][3-1] に格納されていることがわかります。*/

step7  二次元配列の入力１


step8　二次元配列の入力２

 
step9  二次元配列の入力３


step10　二次元配列の入力４


step11  i番目の出力１


step12  i番目の出力２


final  i番目の出力Boss


<【配列の検索】何個ある? Boss>
step1　配列に含まれている?１

step2　配列に含まれている?２

step3　配列に含まれている?３
    
step4　何番目にある？１

step5　何番目にある？２

step6　何番目にある？３

step7  何個ある？１

step8　何個ある？２

final  何個ある？Boss

<【文字列の配列】辞書順に出力 Boss>
step1　配列の書き換え

step2　2変数の入れ替え

step3　配列の要素の入れ替え
    
step4　部分配列

step5　配列の連結

step6　配列のソート

step7  配列の反転

step8　要素のカウント

step9  配列末尾への追加
    
step10　要素の削除

step11  要素の挿入
    
step12  要素数の出力

step13　全要素の出力

step14　i番目の出力

step15　文字列の配列の入力１

step16　文字列の配列の入力２
    
step17　文字列の配列の入力３

step18　i番目の出力１

step19　i番目の出力２

step20　i番目の出力３

step21　i番目の出力４

step22　辞書順に出力１

step23　辞書順に出力２
    
step24　辞書順に出力３
    
final　 辞書順に出力 Boss

<フィボナッチ数>
step1　重複の削除

step2　配列の最大最小

step3　ある数以上以下の要素の列挙１

step4　ある数以上以下の要素の列挙２

step5　ある数以上以下の要素の列挙３
        
step6　二点間の距離１
    
step7　二点間の距離２

final　フィボナッチ数
